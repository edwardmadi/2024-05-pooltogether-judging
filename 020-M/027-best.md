Shambolic Red Gerbil

medium

# Draws can be retried even if a random number is available or the current draw has finished

## Summary

`RngWitnet.isRequestFailed()` does not accurately represent whether a random number is available, making it possible for `startDraw()` to be called in conditions that causes a loss of funds for draw bots.

## Vulnerability Detail

`RngWitnet.isRequestFailed()` determines if a request has failed by checking the response status of a specific block number is equal to `WitnetV2.ResponseStatus.Error`:

[RngWitnet.sol#L115-L118](https://github.com/sherlock-audit/2024-05-pooltogether/blob/1aa1b8c028b659585e4c7a6b9b652fb075f86db3/pt-v5-rng-witnet/src/RngWitnet.sol#L115-L118)

```solidity
    function isRequestFailed(uint32 _requestId) onlyValidRequest(_requestId) public view returns (bool) {
        (uint256 witnetQueryId,,) = witnetRandomness.getRandomizeData(requests[_requestId]);
        return witnetRandomness.witnet().getQueryResponseStatus(witnetQueryId) == WitnetV2.ResponseStatus.Error;
    }
```

Note that `requests[_requestId]`, stores the block number at which the request at `_requestId` was made.

However, `isRequestFailed()` does not accurately reflect if a random number is available. In Witnet, `isRandomized()` (which is used in [`isRequestComplete()`](https://github.com/sherlock-audit/2024-05-pooltogether/blob/1aa1b8c028b659585e4c7a6b9b652fb075f86db3/pt-v5-rng-witnet/src/RngWitnet.sol#L108-L110)) returns `true` and `fetchRandomnessAfter()` (which is used in [`randomNumber()`](https://github.com/sherlock-audit/2024-05-pooltogether/blob/1aa1b8c028b659585e4c7a6b9b652fb075f86db3/pt-v5-rng-witnet/src/RngWitnet.sol#L120-L125)) returns a valid random number as long as there is a successful request at or after the requested block number:

[WitnetRandomnessV2.sol#L334-L336](https://github.com/witnet/witnet-solidity-bridge/blob/2602a43e10b6dae3e681e567ce7de1c0204f4d5e/contracts/apps/WitnetRandomnessV2.sol#L334-L336)

```solidity
    /// @notice Returns `true` only if a successfull resolution from the Witnet blockchain is found for the first 
    /// @notice non-errored randomize request posted on or after the given block number.
    function isRandomized(uint256 _blockNumber)
```

[WitnetRandomnessV2.sol#L128-L136](https://github.com/witnet/witnet-solidity-bridge/blob/2602a43e10b6dae3e681e567ce7de1c0204f4d5e/contracts/apps/WitnetRandomnessV2.sol#L128-L136)

```solidity
    /// @notice Retrieves the result of keccak256-hashing the given block number with the randomness value 
    /// @notice generated by the Witnet Oracle blockchain in response to the first non-errored randomize request solved 
    /// @notice after such block number.
    /// @dev Reverts if:
    /// @dev   i.   no `randomize()` was requested on neither the given block, nor afterwards.
    /// @dev   ii.  the first non-errored `randomize()` request found on or after the given block is not solved yet.
    /// @dev   iii. all `randomize()` requests that took place on or after the given block were solved with errors.
    /// @param _blockNumber Block number from which the search will start
    function fetchRandomnessAfter(uint256 _blockNumber)
```

For example, assume there are two requests:

- Request 1 made at `block.number = 100` failed.
- Request 2 made at `block.number = 101` was successful.

If `isRandomized()` and `fetchRandomnessAfter()` was called for block number 100, they would return `true` and a valid random number respectively. By extension, `RngWitnet.isRequestComplete()` would return `true` for request 1. However, `RngWitnet.isRequestFailed()` also returns `true` for request 1, forming a contradiction.

As such, it is possible for `RngWitnet.isRequestFailed()` to return `true` for a given `_requestId`, even when [`RngWitnet.isRequestComplete()`](https://github.com/sherlock-audit/2024-05-pooltogether/blob/1aa1b8c028b659585e4c7a6b9b652fb075f86db3/pt-v5-rng-witnet/src/RngWitnet.sol#L108-L110) returns `true` and [`RngWitnet.randomNumber()`](https://github.com/sherlock-audit/2024-05-pooltogether/blob/1aa1b8c028b659585e4c7a6b9b652fb075f86db3/pt-v5-rng-witnet/src/RngWitnet.sol#L120-L125) returns a valid random number.

In `DrawManager.startDraw()`, if `RngWitnet.isRequestFailed()` returns `true`, draw bots are allowed to call `startDraw()` again to submit a new request for the current draw to "retry" the randomness request:

[DrawManager.sol#L238-L239](https://github.com/sherlock-audit/2024-05-pooltogether/blob/1aa1b8c028b659585e4c7a6b9b652fb075f86db3/pt-v5-draw-manager/src/DrawManager.sol#L238-L239)

```solidity
      if (!rng.isRequestFailed(lastRequest.rngRequestId)) { // if the request failed
        revert AlreadyStartedDraw();
```

Since `isRequestFailed()` might wrongly return `true` as described above, it is possible for draw bots to retry a randomness request even when a random number is actually available.

Additionally, it is possible for `startDraw()` to be called after a draw has concluded with `finishDraw()`. For example:

- `startDraw()` is called at `block.number = 100`.
- Witnet receives a randomness request from another user/protocol at `block.number = 101`.
- The randomness request at `block.number = 100` fails. 
- The randomness request at `block.number = 101` succeeds.
- `finishDraw()` is called, which works as there is a successful request after `block.number = 100`.
- Now, if `startDraw()` is called, it will pass as `isRequestFailed()` returns `true` for the request at `block.number = 100`.

Note that it is not feasible for draw bots to check if `finishDraw()` has been called before calling `startDraw()`, as another draw bot can front-run their transaction calling `startDraw()` to call `finishDraw()`.

## Impact

`startDraw()` can be called to retry the current draw even when (a) a random number is already available, or (b) when the current draw has already finished. (a) causes a loss of funds to other draw bots that called `startDraw()` in the current draw as their rewards are diluted, while (b) causes a loss of funds to the draw bots that call `startDraw()` after the draw has finished as they never receive rewards.

## Code Snippet

https://github.com/sherlock-audit/2024-05-pooltogether/blob/1aa1b8c028b659585e4c7a6b9b652fb075f86db3/pt-v5-rng-witnet/src/RngWitnet.sol#L115-L118

https://github.com/sherlock-audit/2024-05-pooltogether/blob/1aa1b8c028b659585e4c7a6b9b652fb075f86db3/pt-v5-draw-manager/src/DrawManager.sol#L238-L239

## Tool used

Manual Review

## Recommendation

In `startDraw()`, consider checking `isRequestComplete()` to know if a random number is available:

```diff
-     if (!rng.isRequestFailed(lastRequest.rngRequestId)) { // if the request failed
+     if (rng.isRequestComplete(lastRequest.rngRequestId)) { // if the request failed
        revert AlreadyStartedDraw();
```